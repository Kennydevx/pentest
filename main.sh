#!/bin/bash

# Verifica se um domínio foi passado como argumento
if [ -z "$1" ]; then
    echo "Uso: $0 <dominio>"
    exit 1
fi

# Variáveis globais
ALVO=$1
DATA=$(date +%Y%m%d-%H%M%S)
PASTA_RESULTADOS="resultados-$ALVO-$DATA"
mkdir -p "$PASTA_RESULTADOS"

# Ferramentas e Configurações
NUCLEI_TEMPLATES="cves/"   # Templates que o Nuclei irá usar
NUCLEI_SEVERITY="low,medium,high,critical"  # Severidade para filtro de vulnerabilidades
NUCLEI_THREADS=50  # Número de threads para Nuclei
PARALELO=10  # Número de processos paralelos para requestx e httpx

# Arquivos de Saída
SUBDOMINIOS_FILE="$PASTA_RESULTADOS/subdominios.txt"
ATIVOS_FILE="$PASTA_RESULTADOS/ativos.txt"
HEADERS_DIR="$PASTA_RESULTADOS/headers"
VULNERABILIDADES_FILE="$PASTA_RESULTADOS/vulnerabilidades.txt"
PORTAS_FILE="$PASTA_RESULTADOS/portas.txt"  # Arquivo para escaneamento futuro de portas com Nmap

# Função de log
log() {
    echo "[*] $1"
    echo "[$(date +%H:%M:%S)] $1" >> "$PASTA_RESULTADOS/log.txt"
}

# Função para verificar comandos necessários
checar_comando() {
    if ! command -v "$1" &>/dev/null; then
        log "Erro: O comando '$1' não foi encontrado. Instale-o para continuar."
        exit 1
    fi
}

# Verifica dependências
FERRAMENTAS=("subfinder" "subzy" "httpx" "nuclei" "nmap")
for cmd in "${FERRAMENTAS[@]}"; do
    checar_comando "$cmd"
done

log "Iniciando a análise para o domínio: $ALVO"

# Atualiza os templates do Nuclei
log "Atualizando templates do Nuclei..."
timeout 60 nuclei -update-templates -silent || log "Erro ao atualizar templates."

# Passo 1: Buscar subdomínios (paralelizado)
log "Buscando subdomínios para: $ALVO"
{ subfinder -d "$ALVO" -silent & subzy run --targets "$SUBDOMINIOS_FILE" >> "$PASTA_RESULTADOS/subzy_output.txt" & wait; } | sort -u > "$SUBDOMINIOS_FILE"
SUBDOMINIOS_ENCONTRADOS=$(wc -l < "$SUBDOMINIOS_FILE")
log "Subdomínios encontrados: $SUBDOMINIOS_ENCONTRADOS"
if [ "$SUBDOMINIOS_ENCONTRADOS" -eq 0 ]; then
    log "Nenhum subdomínio encontrado. Encerrando."
    exit 1
fi

# Função para garantir que URLs tenham o protocolo correto
formatar_url() {
    url=$1
    if [[ ! "$url" =~ ^http[s]?:// ]]; then
        echo "http://$url"
    else
        echo "$url"
    fi
}

# Passo 2: Verificar subdomínios ativos
log "Verificando subdomínios ativos..."
while read -r sub; do
    sub=$(echo "$sub" | xargs)  # Remove espaços em branco
    sub=$(formatar_url "$sub")   # Formata a URL

    # Log para cada subdomínio antes da verificação
    log "Verificando subdomínio: $sub"

    if [[ -n "$sub" ]]; then
        # Usar o httpx diretamente
        httpx --verbose --follow-redirects --timeout 10 --http2 "$sub" >> "$ATIVOS_FILE" || log "Erro ao verificar $sub."
    else
        log "URL inválida: $sub"  # Log para URLs inválidas
    fi
done < "$SUBDOMINIOS_FILE"

# Passo 2: Verificar subdomínios ativos
log "Verificando subdomínios ativos..."
while read -r sub; do
    sub=$(echo "$sub" | xargs)  # Remove espaços em branco
    sub=$(formatar_url "$sub")   # Formata a URL

    # Log para cada subdomínio antes da verificação
    log "Verificando subdomínio: $sub"

    if [[ -n "$sub" && "$sub" != "http://" && "$sub" != "https://" ]]; then
        echo "$sub" | httpx --verbose --follow-redirects --timeout 10 --http2 >> "$ATIVOS_FILE" || log "Erro ao verificar $sub."
    else
        log "URL inválida: $sub"  # Log para URLs inválidas
    fi
done < "$SUBDOMINIOS_FILE"



SUBDOMINIOS_ATIVOS=$(wc -l < "$ATIVOS_FILE")
log "Subdomínios ativos: $SUBDOMINIOS_ATIVOS"
if [ "$SUBDOMINIOS_ATIVOS" -eq 0 ]; then
    log "Nenhum subdomínio ativo. Encerrando."
    exit 1
fi

# Passo 3: Capturar cabeçalhos HTTP (Opcional)
#log "Capturando cabeçalhos HTTP..."
#mkdir -p "$HEADERS_DIR"
#while read -r sub; do
#    sub=$(formatar_url "$sub")
#    if [[ -n "$sub" ]]; then  # Verifique se o sub está vazio
#        requestx -url "$sub" -json -o "$HEADERS_DIR/headers-$(basename $sub).json" || log "Erro ao capturar cabeçalhos de $sub."
#    fi
#done < "$ATIVOS_FILE"


# Passo 4: Escanear vulnerabilidades com Nuclei
log "Iniciando scanner de vulnerabilidades com Nuclei..."
cut -d ' ' -f1 "$ATIVOS_FILE" | nuclei -silent -t "$NUCLEI_TEMPLATES" -severity "$NUCLEI_SEVERITY" -c "$NUCLEI_THREADS" -o "$VULNERABILIDADES_FILE" || log "Erro no scanner de vulnerabilidades."
VULNERABILIDADES_ENCONTRADAS=$(wc -l < "$VULNERABILIDADES_FILE")

# Passo 5: Chamar script externo para Nmap e vulnerabilidades adicionais
NMAP_SCRIPT="./nmap_scan.sh"  # Caminho do script externo

log "Iniciando escaneamento com Nmap e verificações adicionais..."
if [ -f "$NMAP_SCRIPT" ]; then
    bash "$NMAP_SCRIPT" "$ATIVOS_FILE" "$PASTA_RESULTADOS" || log "Erro ao executar o script Nmap."
else
    log "Erro: Script de Nmap não encontrado em $NMAP_SCRIPT"
    exit 1
fi

# Relatório final
log "Processo concluído!"
log "Subdomínios ativos: $SUBDOMINIOS_ATIVOS"
log "Vulnerabilidades encontradas: $VULNERABILIDADES_ENCONTRADAS"
log "Tempo total de execução: $(SECONDS) segundos"

# Exibe os resultados finais
echo -e "\n[Resumo]"
echo "Subdomínios ativos: $ATIVOS_FILE"
echo "Headers capturados: $HEADERS_DIR/"
echo "Vulnerabilidades: $VULNERABILIDADES_FILE"
echo "Portas abertas: $PORTAS_FILE"

